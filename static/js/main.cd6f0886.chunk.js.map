{"version":3,"sources":["RadioButtons.jsx","utilities/Dice.js","utilities/probabilityTable.js","utilities/Risk.js","utilities/RollNode.js","App.js","serviceWorker.js","index.js"],"names":["RadioButton","styled","button","props","selected","RadioButtons","buttons","callback","useState","setSelected","className","map","label","value","key","type","onClick","handleSelect","makeButtons","sortAscending","array","sort","a","b","sortDescending","DICE_DEFAULT","values","this","VALUES","probabilityTable","Modifiers","dice","defender","attacker","RollNode","rollPair","parent","children","modifiers","isRoot","atk","def","outcome","modifierKey","battleKey","outcomeKey","getOutcomeProbability","maxAttackers","maxDefenders","lossFromParent","parentProbs","node","probabilityArray","push","getRelativeProbability","reduce","childNode","length","getLeafProbs","probs","isLeaf","probability","getRootProbability","i","nAttackers","nDefenders","nodeAtk","nodeDef","outcomes","loseTroops","newNode","makeOutcomesTree","addChild","probabilities","getLeafProbabilities","reduceOutcomes","getDepth","depth","getRoot","retrieveLeaves","leaves","finalProbs","outcomeIndex","obj","indexOf","attackers","defenders","troopsLost","App","numAttackers","setNumAttackers","numDefenders","setNumDefenders","setModifiers","oddsAttackWins","setOddsAttackWins","oddsAttackLoses","setOddsAttackLoses","formatPercent","decimal","number","parseFloat","toFixed","displayTotalOutcome","outcomeArray","probabilitiesSum","displayOutcomes","displayedOutcomes","onSubmit","event","preventDefault","treeLeafOdds","getOdds","attackWins","attackLoses","calculateOdds","htmlFor","required","name","id","min","max","placeholder","onChange","target","modifier","autoFocus","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"ipBAGA,IAAMA,E,KAAcC,EAAOC,OAAV,KAIK,SAAAC,GAAK,OAAIA,EAAMC,SAAN,iBACpB,SAAAD,GAAK,OAAIA,EAAMC,SAAN,iBAiBPC,EAAe,SAAC,GAA2B,IAAzBC,EAAwB,EAAxBA,QAASC,EAAe,EAAfA,SAAe,EACrBC,mBAAS,IADY,mBAC9CJ,EAD8C,KACpCK,EADoC,KA6BrD,OACE,yBAAKC,UAAU,gBAtBG,SAACJ,GAkBnB,OAjBqBA,EAAQK,KAAI,SAACT,GAAY,IACpCU,EAAiBV,EAAjBU,MAAOC,EAAUX,EAAVW,MAIf,OACE,kBAACb,EAAD,CACEc,IAAKD,EACLE,KAAK,SACLX,SAN8BS,IAAUT,EAOxCY,QAAS,kBAhBI,SAACH,GACpBJ,EAAYI,GACZN,EAASM,GAcYI,CAAaJ,KAE3BD,MAUJM,CAAYZ,K,cClDNa,G,MAAgB,SAACC,GAE5B,OADeA,EAAMC,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAIC,OAI7BC,EAAiB,SAACJ,GAE7B,OADeA,EAAMC,MAAK,SAACC,EAAGC,GAAJ,OAAUA,EAAID,MAc7BG,EAAe,I,WAR1B,WAAYC,GAAS,oBACnBC,KAAKC,OAASF,E,gDAGJ,OAAOP,EAAcQ,KAAKC,QAAQ,K,0BAClC,OAAOJ,EAAeG,KAAKC,QAAQ,O,KAGrB,CAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,ICvBxCC,EAAmB,CAC9B,QAAU,CACR,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,OAEb,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,OAEb,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,QAGf,QAAU,CACR,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,OAEb,QAAU,CACR,QAAY,MACZ,aAAiB,KACjB,OAAW,OAEb,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,QAGf,QAAU,CACR,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,OAEb,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,QAGf,QAAU,CACR,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,OAEb,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,QAGf,QAAU,CACR,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,OAEb,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,QAGf,QAAU,CACR,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,OAEb,QAAU,CACR,QAAY,MACZ,aAAiB,MACjB,OAAW,SCzEJC,EACX,aAEI,IAAD,yDAFyC,CAC1CC,KAAMN,EAAcO,SAAW,GAAIC,SAAW,IADlCF,EAEX,EAFWA,KAAOC,EAElB,EAFkBA,SAAUC,EAE5B,EAF4BA,SAE5B,oBACDN,KAAKI,KAAOA,GAAQN,EACpBE,KAAKK,SAAWA,GAAY,GAC5BL,KAAKM,SAAWA,GAAY,ICPnBC,GDWE,IAAIJ,ECXE,WACnB,WAAYK,GAAW,oBACrBR,KAAKS,OAAS,KACdT,KAAKU,SAAW,GAChBV,KAAKQ,SAAWA,EAJC,mEAwHKG,GACtB,OAAIX,KAAKY,SAAmB,ED4BK,SAACC,EAAKC,EAAKC,EAASJ,GAGvD,IAAIK,EACc,OAAdL,EACFK,EAAc,UACLL,GAAaA,EAAUN,UACL,iBAAvBM,EAAUN,WAA6BW,EAAc,gBAC9B,WAAvBL,EAAUN,WAAuBW,EAAc,WAEnDA,EAAc,UAEhB,IAAMC,EAAS,WAAOJ,EAAP,YAAcC,EAAd,KACTI,EAAU,WAAOH,EAAQ,GAAf,YAAqBA,EAAQ,GAA7B,KAoBhB,OATyBb,EAAiBe,GAAWC,GAAYF,GC7ClDG,CAJGnB,KAAKS,OAAOW,aACZpB,KAAKS,OAAOY,aACbrB,KAAKsB,eAEyCX,KAhI5C,yCAwICA,GAgBlB,OAdoB,SAAdY,EAAeC,GAAiC,IAA3BC,EAA0B,uDAAP,GAM5C,OAJAA,EAAiBC,KAAKF,EAAKG,uBAAuBhB,IAG7Ca,EAAKZ,UAAYW,EAAYC,EAAKf,OAAQgB,GACxCA,EAGaF,CAAYvB,MAII4B,QAAO,SAACjC,EAAGC,GAAJ,OAAUD,EAAIC,OAvJ1C,+BA+JTiC,GAAa7B,KAAKU,SAASgB,KAAKG,KA/JvB,+BAqKP,OAAiC,IAAzB7B,KAAKU,SAASoB,SArKf,+BA2KP,OAAwB,OAAhB9B,KAAKS,SA3KN,2CAoMGE,GAkBpB,OAjBqB,SAAfoB,EAAgBP,GAAsB,IAAhBQ,EAAe,uDAAP,GAClC,GAAIR,EAAKS,SAMP,OALAD,EAAMN,KAAK,CAETX,QAASS,EAAKhB,SACd0B,YAAaV,EAAKW,mBAAmBxB,KAEhCqB,EAEP,IAAI,IAAII,EAAI,EAAGA,EAAIZ,EAAKd,SAASoB,OAAQM,IACvCL,EAAaP,EAAKd,SAAS0B,GAAIJ,GAGnC,OAAOA,EAGiBD,CAAa/B,QArNtB,yCA8NjB,IADkB,EAQS,CAPVA,KAOqBqC,WAPrBrC,KAO0CsC,YAApDC,EARW,KAQFC,EARE,KASlB,GAAgB,IAAZD,GAA6B,IAAZC,EAAiB,OARrBxC,KAYjB,IADA,IAAMyC,EAAWlC,EAASmC,WAAWH,EAASC,GACrCJ,EAAI,EAAGA,EAAIK,EAASX,OAAQM,IAAK,CAExC,IAAMO,EAAU,IAAIpC,EAASkC,EAASL,IACtCO,EAAQlC,OAfOT,KAgBf2C,EAAQC,mBAhBO5C,KAiBN6C,SAASF,GAEpB,OAnBiB3C,OA9NA,8BAqPVW,GACPX,KAAK4C,mBACL,IAAME,EAAgB9C,KAAK+C,qBAAqBpC,GAEhD,OADwBJ,EAASyC,eAAeF,KAxP/B,iCASC,OAAO9C,KAAKQ,SAAS,KATtB,iCAUC,OAAOR,KAAKQ,SAAS,KAVtB,mCAaG,OAAOR,KAAKqC,YAAc,EAAI,EAAIrC,KAAKqC,aAb1C,mCAcG,OAAOrC,KAAKsC,YAAc,EAAI,EAAItC,KAAKsC,aAd1C,4BAkCjB,OALiB,SAAXW,EAAYzB,GAAqB,IAAf0B,EAAc,uDAAN,EAC9B,OAAoB,OAAhB1B,EAAKf,OAA0ByC,EACrBD,EAASzB,EAAKf,OAAQyC,EAAQ,GAE5BD,CAASjD,QAjCV,2BAgDjB,OALgB,SAAVmD,EAAW3B,GACf,OAAoB,OAAhBA,EAAKf,OAA0Be,EACrB2B,EAAQ3B,EAAKf,QAEZ0C,CAAQnD,QA/CR,qCAwDjB,OAAoB,OAAhBA,KAAKS,OAA0B,CAAC,EAAG,GAEhB,CACrBT,KAAKS,OAAO4B,WAAarC,KAAKqC,WAC9BrC,KAAKS,OAAO6B,WAAatC,KAAKsC,cA5Df,6BAmFjB,OAbuB,SAAjBc,EAAkB5B,GAAuB,IAAjB6B,EAAgB,uDAAP,GACrC,GAAI7B,EAAKS,SAEP,OADAoB,EAAO3B,KAAKF,GACL6B,EAEP,IAAK,IAAIjB,EAAI,EAAGA,EAAIZ,EAAKd,SAASoB,OAAQM,IACxCgB,EAAe5B,EAAKd,SAAS0B,GAAIiB,GAGrC,OAAOA,EAGSD,CAAepD,SAlFhB,sCA0FIyC,GAGrB,IAFA,IAAMa,EAAa,GAEVlB,EAAI,EAAGA,EAAIK,EAASX,OAAQM,IAAK,CAAC,IAAD,EACPK,EAASL,GAAlCrB,EADgC,EAChCA,QAASmB,EADuB,EACvBA,YAEXqB,EADiBD,EAAWtE,KAAI,SAAAwE,GAAG,OAAIA,EAAIzC,WACb0C,QAAf,UAA0B1C,IAG3CwC,GAAgB,EAClBD,EAAWC,GAAcrB,YACzBoB,EAAWC,GAAcrB,YAAcA,EAGvCoB,EAAW5B,KAAK,CACdX,QAAQ,GAAD,OAAKA,GACZmB,YAAaA,IAInB,OAAOoB,IA9GU,iCAoLAI,EAAWC,GAC5B,IAAMC,EAAcF,GAAa,GAAKC,GAAa,EAAK,EAAI,EAGtDlB,EAAW,CACf,CAACiB,EAAYE,EAAYD,GACzB,CAACD,EAAWC,EAAYC,IAG1B,GAAmB,IAAfA,EAAkB,CACpBnB,EAASf,KAAK,CAACgC,EAAY,EAAGC,EAAY,IADtB,MAES,CAAClB,EAAS,GAAIA,EAAS,IAAnDA,EAAS,GAFU,KAENA,EAAS,GAFH,KAItB,OAAOA,MAjMU,MC+JNoB,EA/JH,WAAO,IAAD,EACwBhF,mBAAS,GADjC,mBACTiF,EADS,KACKC,EADL,OAEwBlF,mBAAS,GAFjC,mBAETmF,EAFS,KAEKC,EAFL,OAGkBpF,mBAAS,CAAEwB,SAAU,KAHvC,mBAGTM,EAHS,KAGEuD,EAHF,OAK4BrF,mBAAS,IALrC,mBAKTsF,EALS,KAKOC,EALP,OAM8BvF,mBAAS,IANvC,mBAMTwF,EANS,KAMQC,EANR,KA6BVC,EAAgB,SAACC,GACrB,IAAMC,EAA+B,IAAtBC,WAAWF,GAC1B,MAAM,GAAN,OAAUC,EAAOE,QAAQ,GAAzB,MAGIC,EAAsB,SAACC,EAAc5F,GACzC,IAAI6F,EAAmB,KAMvB,OALID,EAAa/C,OAAS,IACxBgD,EAAmBD,EAAa7F,KAAI,SAAC+B,GAAD,OAAaA,EAAQmB,eACtDN,QAAO,SAACjC,EAAEC,GAAH,OAASD,EAAIC,KACvBkF,EAAmBP,EAAcO,IAGjC,oCACE,uBAAG/F,UAAU,8BAA8BE,GAC3C,uBAAGF,UAAU,8BACV+F,KAMHC,EAAkB,SAACF,GACvB,IAAMG,EAAoBH,EAAa7F,KAAI,SAAC+B,GAC1C,OACE,yBAAKhC,UAAU,6BAA6BI,IAAK4B,EAAQA,SACvD,2BAAIA,EAAQA,SACZ,2BAAIwD,EAAcxD,EAAQmB,kBAKhC,OACE,wBAAInD,UAAU,+BACZ,yBAAKA,UAAU,mCACb,sCACA,2CAEDiG,IAYP,OACE,yBAAKjG,UAAU,OACb,4BAAQA,UAAU,aAChB,uBAAGA,UAAU,oBAAb,eACA,uBAAGA,UAAU,uBAAb,2BAGF,yBAAKA,UAAU,iBACb,yBAAKA,UAAU,yBACX6F,EAAoBT,EAAgB,iBACpCY,EAAgBZ,IAEpB,yBAAKpF,UAAU,yBACX6F,EAAoBP,EAAiB,kBACrCU,EAAgBV,KAItB,0BAAMtF,UAAU,aAAakG,SAAU,SAACC,GAAD,OAzFrB,SAACA,GACrBA,EAAMC,iBAQN,IANA,IACMC,EADW,IAAI7E,EAAS,CAACuD,EAAcE,IACfqB,QAAQ1E,GAEhC2E,EAAa,GACbC,EAAc,GAEXnD,EAAI,EAAGA,EAAIgD,EAAatD,OAAQM,IACJ,MAA/BgD,EAAahD,GAAGrB,QAAQ,GAC1BuE,EAAW5D,KAAK0D,EAAahD,IAE7BmD,EAAY7D,KAAK0D,EAAahD,IAIlCgC,EAAkBkB,GAClBhB,EAAmBiB,GAuEiCC,CAAcN,KAC9D,yBAAKnG,UAAU,kCACb,uBAAGA,UAAU,4BAAb,UACA,yBAAKA,UAAU,eAEf,yBAAKA,UAAU,0CACb,2BAAOA,UAAU,yBAAyB0G,QAAQ,gBAAlD,aAGA,yBAAK1G,UAAU,0BACb,2BACEK,KAAK,SAASsG,UAAQ,EACtBC,KAAK,eAAeC,GAAG,eACvBC,IAAI,IAAIC,IAAI,KACZ5G,MAAO4E,EAAciC,YAAY,IACjCC,SAAU,SAACd,GAAD,OAAWnB,EAAgBmB,EAAMe,OAAO/G,YAKxD,yBAAKH,UAAU,0CACb,2BAAOA,UAAU,yBAAyB0G,QAAQ,gBAAlD,aAGA,yBAAK1G,UAAU,0BACb,2BACEK,KAAK,SAASsG,UAAQ,EACtBC,KAAK,eAAeC,GAAG,eACvBC,IAAI,IAAIC,IAAI,KACZ5G,MAAO8E,EAAc+B,YAAY,IACjCC,SAAU,SAACd,GAAD,OAAWjB,EAAgBiB,EAAMe,OAAO/G,cAO1D,yBAAKH,UAAU,uBACb,uBAAGA,UAAU,4BAAb,aACA,yBAAKA,UAAU,qBACb,2BAAO0G,QAAQ,qBAAf,kBACA,yBAAK1G,UAAU,0BACb,kBAAC,EAAD,CACEJ,QAAS,CACP,CAAEO,MAAO,GAAID,MAAO,QACpB,CAAEC,MAAO,SAAUD,MAAO,UAC1B,CAAEC,MAAO,eAAgBD,MAAO,kBAElCL,SAxEU,SAACsH,GACvBhC,EAAa,CAAE7D,SAAU6F,UA6ErB,4BAAQnH,UAAU,qBAAqBK,KAAK,SAAS+G,WAAS,GAA9D,gBCpJYC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.cd6f0886.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport styled from 'styled-components';\n\nconst RadioButton = styled.button`\n  appearance: none;\n  padding: 0.75rem 1rem;\n  font-size: 1rem;\n  border: solid 1px ${props => props.selected ? `blue` : `grey`};\n  color: ${props => props.selected ? `blue` : `grey` };\n\n  &:focus,\n  &:hover {\n    text-decoration: underline;\n    outline: thin;\n  }\n\n  &:first-child {\n    border-radius: 0.25rem 0 0 0.25rem;\n  }\n\n  &:last-child {\n    border-radius: 0 0.25rem 0.25rem 0;\n  }\n`;\n\nexport const RadioButtons = ({ buttons, callback }) => {\n  const [selected, setSelected] = useState(\"\");\n\n  const handleSelect = (value) => {\n    setSelected(value);\n    callback(value);\n  };\n\n  const makeButtons = (buttons) => {\n    const radioButtons = buttons.map((button) => {\n      const { label, value } = button;\n\n      const isSelected = () => { return value === selected ? true : false };\n\n      return (\n        <RadioButton\n          key={value}\n          type=\"button\"\n          selected={isSelected(value)}\n          onClick={() => handleSelect(value)}\n        >\n          {label}\n        </RadioButton> \n      );\n    });\n\n    return radioButtons;\n  };\n\n  return (\n    <div className=\"radioButtons\">\n      {makeButtons(buttons)}\n    </div>\n  );\n};\n\n\n","import {\n  getPermutations,\n} from './Probabilities';\n\n\n/* Utilities */\nexport const sortAscending = (array) => {\n  const sorted = array.sort((a, b) => a - b);\n  return sorted;\n};\n\nexport const sortDescending = (array) => {\n  const sorted = array.sort((a, b) => b - a); \n  return sorted;\n};\n\n/* Dice Object */\nclass Dice {\n  constructor(values) {\n    this.VALUES = values;\n  }\n\n  get min() { return sortAscending(this.VALUES)[0]};\n  get max() { return sortDescending(this.VALUES)[0]};\n};\n\nexport const DICE_DEFAULT = new Dice([1, 2, 3, 4, 5, 6]);\n\n/* Dice functions */\nconst getRandomNumInclusive = (min = 0, max = 1) => {\n  [min, max] = sortAscending(min, max); // sort to determine real min/max\n  const randomNum = Math.floor(min + (Math.random() * (max - min + 1)));\n  return randomNum;\n};\n\n/**\n * Get an inclusive number between min and max values\n * @param {Number} min -- smallest possible dice roll\n * @param {Number} max -- largest possible dice roll\n */\nexport const rollDice = (min = DICE_DEFAULT.MIN, max = DICE_DEFAULT.MAX) => {\n  const roll = getRandomNumInclusive(min, max);\n  return roll;\n};\n\n/**\n * Get an array of inclusive values between min and max values \n * @param {Number} min -- smallest possible dice roll\n * @param {Number} max -- largest possible dice roll\n */\nexport const rollMultipleDice = (numDice = 1, min, max) => {\n  const rolls = [];\n  for (let i = 0; i < numDice; i++) {\n    const roll = rollDice(min, max);\n    rolls.push(roll);\n  }\n  return rolls;\n};\n\n/**\n * Retrieve all possible permutations for a number of dice rolls\n * @param {[]} diceValues -- possible outcomes from dice. Generally a number.\n * @param {Number} numChoices -- number of individual outcomes to collect\n */\nexport const getDicePermutations = (diceValues = DICE_DEFAULT.VALUES, numChoices = 1) => {\n  if (typeof diceValues === 'number') {\n    [diceValues, numChoices] = [DICE_DEFAULT.VALUES, diceValues]\n  }\n\n  const dicePermutations = getPermutations(diceValues, numChoices);\n  return dicePermutations;\n};\n","/**\n * Query: starting troops . outcome . modifiers\n */\nexport const probabilityTable = {\n  '[3,2]' : {\n    '[2,0]' : {\n      'default' : 0.2926,\n      'ammoShortage' : 0.1838,\n      'bunker' : 0.3524,\n    },\n    '[1,1]' : {\n      'default' : 0.3358,\n      'ammoShortage' : 0.3057,\n      'bunker' : 0.4084,\n    },\n    '[0,2]' : {\n      'default' : 0.3716,\n      'ammoShortage' : 0.5105,\n      'bunker' : 0.2392,\n    }\n  },\n  '[2,2]' : {\n    '[2,0]' : {\n      'default' : 0.4483,\n      'ammoShortage' : 0.3125,\n      'bunker' : 0.5332,\n    },\n    '[1,1]' : {\n      'default' : 0.3241,\n      'ammoShortage' : 0.3750,\n      'bunker' : 0.3202,\n    },\n    '[0,2]' : {\n      'default' : 0.2276,\n      'ammoShortage' : 0.3125,\n      'bunker' : 0.1466,\n    }\n  },\n  '[1,2]' : {\n    '[1,0]' : {\n      'default' : 0.7454,\n      'ammoShortage' : 0.5787,\n      'bunker' : 0.8611,\n    },\n    '[0,1]' : {\n      'default' : 0.2546,\n      'ammoShortage' : 0.4213,\n      'bunker' : 0.1389,\n    },\n  },\n  '[3,1]' : {\n    '[1,0]' : {\n      'default' : 0.3403,\n      'ammoShortage' : 0.1736,\n      'bunker' : 0.5062,\n    },\n    '[0,1]' : {\n      'default' : 0.6597,\n      'ammoShortage' : 0.8264,\n      'bunker' : 0.4938,\n    },\n  },\n  '[2,1]' : {\n    '[1,0]' : {\n      'default' : 0.4213,\n      'ammoShortage' : 0.2546,\n      'bunker' : 0.5833,\n    },\n    '[0,1]' : {\n      'default' : 0.5787,\n      'ammoShortage' : 0.7554,\n      'bunker' : 0.4167,\n    },\n  },\n  '[1,1]' : {\n    '[1,0]' : {\n      'default' : 0.5833,\n      'ammoShortage' : 0.4167,\n      'bunker' : 0.7222,\n    },\n    '[0,1]' : {\n      'default' : 0.4167,\n      'ammoShortage' : 0.5833,\n      'bunker' : 0.2778,\n    },\n  },\n};\n","import {\n  DICE_DEFAULT,\n  sortDescending,\n  getDicePermutations,\n} from './Dice';\n\nimport {\n  probabilityTable, \n} from './probabilityTable';\n\nexport class Modifiers {\n  constructor({ dice , defender, attacker } = {\n    dice: DICE_DEFAULT, defender : '', attacker : ''\n  }) {\n    this.dice = dice || DICE_DEFAULT;\n    this.defender = defender || '';\n    this.attacker = attacker || '';\n  }\n}\n\nconst defMod = new Modifiers();\n\n/**\n * Compare dice rolls. \n * @param {[Number]} attackerRolls -- rolls by attacker\n * @param {[Number]} defenderRolls -- rolls by defender\n * @returns {[Number]} -- [0] is attack troops lost, [1] is defense troops lost\n */\nconst compareRolls = (attackerRolls, defenderRolls) => {\n  const numToCompare = attackerRolls.length >= defenderRolls.length\n    ? defenderRolls.length\n    : attackerRolls.length;\n\n  let [attackLosses, defenseLosses]  = [0, 0];\n  for (let i = 0; i < numToCompare; i++) {\n    // Compare rolls: attack only wins when higher than defense roll (lose tie)\n    attackerRolls[i] > defenderRolls[i]\n    ? defenseLosses += 1 // def loses, remove defending troop\n    : attackLosses += 1; // atk loses, remove attacking troop\n  }\n  return [attackLosses, defenseLosses];\n}\n\n/**\n * Compare dice rolls specifically in enclave condition\n * @param {[Number]} attackerRolls -- rolls by attacker\n * @param {[Number]} defenderRolls -- rolls by defender\n * @returns {[Number]} -- [0] is attack troops lost, [1] is defense troops lost\n */\nconst enclaveCompareRolls = (attackerRolls, defenderRolls) => {\n  const [numAtk, numDef ] = [attackerRolls.length, defenderRolls.length];\n  \n  // if there are three attack dice\n  // and if the three numbers are the same (e.g. 5,5,5 or 3,3,3)\n  // and if that number is bigger than the lowest of defender\n  // OBLITERATE\n  // enclave ability check\n  if (\n    numAtk === 3\n    && attackerRolls[0] === attackerRolls[1]\n    && attackerRolls[1] === attackerRolls[2]\n    && attackerRolls[0] > defenderRolls[numDef - 1])\n  {\n    // console.log('OBLITERATE'); // interact with actual troop counter\n    /**\n     * add 100 just so we get a clearly different outcome. However this messes\n     * up average loss since it doesn't know the normal troops, so change this\n     * later\n     */ \n    return [0, numDef + 100]; \n  } else {\n    // just do a regular comparison\n    return compareRolls(attackerRolls, defenderRolls);\n  }\n}\n\n/**\n * calculate battle outcome probabilities\n * @param {Number} nAtk -- number attackers, usually between 1 - 3\n * @param {Number} nDef -- number dependers, usually 1 or 2\n * @param {[String]} modifiers \n */\nexport const calcBattleOdds = (nAtk = 1, nDef = 1, modifiers = defMod) => {\n  if (!(modifiers instanceof Modifiers)) {\n\n    if (modifiers['dice'] || modifiers['defender'] || modifiers['attacker']) {\n      modifiers = new Modifiers(modifiers);\n      // console.log(modifiers);\n    } else {\n      modifiers = defMod;\n    }\n  }\n\n  const { dice, defender, attacker } = modifiers;\n\n  const dicePermutations = getDicePermutations(dice.VALUES, nAtk + nDef);\n  const permutationsCount = dicePermutations.length;\n  \n  const combinationResults = [];\n\n  for (let i = 0; i < permutationsCount; i++) {\n    const currentCombination = dicePermutations[i];\n    const atkRolls = sortDescending(currentCombination.slice(0, nAtk));\n    const defRolls = sortDescending(currentCombination.slice(nAtk));\n\n    if (defender === 'ammoShortage') {\n      // console.log('ammo shortage: -1 to highest defensive roll');\n      defRolls[0] = defRolls[0] - 1;\n    } else if (defender === 'bunker') {\n      // console.log('bunker: +1 to highest defensive roll');\n      defRolls[0] = defRolls[0] + 1;\n    }\n\n    if (attacker === 'enclave') {\n      const result = enclaveCompareRolls(atkRolls, defRolls);\n      combinationResults.push(result);\n      continue; // don't do the regular compare, just go to next permutation\n    }\n\n    const combinationResult = compareRolls(atkRolls, defRolls);\n    // console.log(`${atkRolls}:${defRolls} ==> ${combinationResult}`);\n    combinationResults.push(combinationResult);\n  }\n\n  const outcomes = {};\n  for (let i = 0; i < permutationsCount; i++) {\n    const atkLosses = combinationResults[i][0];\n    const defLosses = combinationResults[i][1];\n    // const outcomeKey = `ATK -${atkLosses}, DEF -${defLosses}`;\n    // const outcomeKey = `[ ${atkLosses}, ${defLosses} ]`;\n    const outcomeKey = [ atkLosses, defLosses ];\n\n    if(!outcomes[outcomeKey]) {\n      outcomes[outcomeKey] = 1;\n    } else {\n      outcomes[outcomeKey] += 1;\n    }\n  }\n  outcomes.total = Math.pow(dice.min + dice.max - 1, nAtk + nDef);\n  // console.log(outcomes);\n  return outcomes;\n\n  // const odds = {};\n  // odds.situation = `${nAtk}Atk v ${nDef}Def`;\n  // odds.modifiers = modifiers;\n  // odds.totalOutcomes = Math.pow(dice.min + dice.max - 1, nAtk + nDef);\n  // const outcomeKeys = Object.keys(outcomes);\n  // for (let i = 0; i < outcomeKeys.length; i++) {\n  //   const outcomePercent =  (\n  //     outcomes[outcomeKeys[i]] / permutationsCount * 100\n  //   ).toFixed(3);\n  //   // odds[outcomeKeys[i]] = `${outcomePercent} (${outcomes[outcomeKeys[i]]})`;\n  //   odds[outcomeKeys[i]] = `${outcomePercent}`;\n  // }\n  // console.log(odds);\n  // return odds;\n};\n\nexport const getOutcomeProbability = (atk, def, outcome, modifiers) => {\n  // Make Keys \n \n  let modifierKey;\n  if (modifiers === null) {\n    modifierKey = 'default';\n  } else if (modifiers && modifiers.defender) {\n    if (modifiers.defender === 'ammoShortage') modifierKey = 'ammoShortage';\n    if (modifiers.defender === 'bunker') modifierKey = 'bunker';\n  } else {\n    modifierKey = 'default';\n  }\n  const battleKey = `[${atk},${def}]`;\n  const outcomeKey = `[${outcome[0]},${outcome[1]}]`;\n\n  // console.log('battleKey:', battleKey);\n  // console.log('outcomeKey:', outcomeKey);\n  // console.log('modifierKey:', modifierKey);\n\n\n  // console.log(probabilityTable);\n  // console.log(probabilityTable[battleKey][outcomeKey][modifierKey]);\n\n  // const probability = 0;\n  const requestedOutcome = probabilityTable[battleKey][outcomeKey][modifierKey];\n\n\n  // const allOutcomes = calcBattleOdds(atk, def, modifiers);\n  // const requestedOutcome = {};\n  // requestedOutcome.outcome = allOutcomes[outcome] || 0;\n  // requestedOutcome.total = Math.pow(6, atk + def);\n  // requestedOutcome.outcome = probability * requestedOutcome.total;\n\n  return requestedOutcome;\n};\n","import {\n  getOutcomeProbability,\n} from './Risk';\n\n\n/**\n * RollNode object to create tree\n * @param {[Number]} rollPair -- array of two numbers: [nAtk, nDef]\n */\nexport const RollNode = class {\n  constructor(rollPair) {\n    this.parent = null;\n    this.children = [];\n    this.rollPair = rollPair;\n  }\n\n  // --------------------- Getters/Setters (properties) --------------------- //\n  // Number of total troops on the territory that can attack or defend\n  get nAttackers () { return this.rollPair[0]; };\n  get nDefenders () { return this.rollPair[1]; };\n\n  // Number of troops in attacker's best-case scenario battle\n  get maxAttackers () { return this.nAttackers >= 3 ? 3 : this.nAttackers; };\n  get maxDefenders () { return this.nDefenders >= 2 ? 2 : this.nDefenders; };\n\n  // TODO: calculate probabilities: child to parent\n  // Q: calculate from within or pass as a calculated value when creating node? \n  // Or maybe make it part of loseTroops. So rollPair will be three values:\n  // 1. total number of attackers (can be greater than 3)\n  // 2. total number of defenders (can be greater than 2)\n  // 3. probability relative to parent\n\n  /**\n   * The depth of a node is the number of edges from it to the root node. For\n   * each parent including the root node, increase node depth by 1. \n   * @return {number} nodeDepth: any positive integer including 0\n   */\n  get depth () {\n    const getDepth = (node, depth = 0) => {\n      if (node.parent === null) { return depth; } // base case no parent\n      else { return getDepth(node.parent, depth + 1); } // recursive case\n    };\n    const nodeDepth = getDepth(this);\n    return nodeDepth;\n  };\n\n  /**\n   * The root node of a tree is the top-most node, that is, it has no parent.\n   * Find the root by checking for parent nodes.\n   * @return {RollNode} rootNode: return a RollNode\n   */\n  get root () {\n    const getRoot = (node) => { \n      if (node.parent === null) { return node; } // base case: no parent\n      else { return getRoot(node.parent); } // recursive case: check parent\n    };\n    const rootNode = getRoot(this);\n    return rootNode;\n  };\n\n  /**\n   * Compare this rollPair to parent rollPair to see where troops were lost\n   * @return {[number]} [attackers lost, defenders lost]\n   */\n  get lossFromParent () {\n    if (this.parent === null) { return [0, 0]; }\n\n    const lossFromParent = [\n      this.parent.nAttackers - this.nAttackers,\n      this.parent.nDefenders - this.nDefenders,\n    ];\n    return lossFromParent;\n  };\n\n  /**\n   * Get all leaf-nodes.\n   * @return {[RollNode]} -- array of leaf nodes\n   */\n  get leaves () {\n    const retrieveLeaves = (node, leaves = []) => {\n      if (node.isLeaf()) {\n        leaves.push(node);\n        return leaves;\n      } else {\n        for (let i = 0; i < node.children.length; i++) {\n          retrieveLeaves(node.children[i], leaves);\n        }\n      }\n      return leaves;\n    };\n\n    const allLeaves = retrieveLeaves(this);\n    return allLeaves;\n  };\n\n  /**\n   * Sum probabilities of leaf nodes with matching outcomes\n   * @param {[{ outcome: string, probability: number }]} outcomes \n   */\n  static reduceOutcomes (outcomes) {\n    const finalProbs = [];\n    \n    for (let i = 0; i < outcomes.length; i++) {\n      const { outcome, probability } = outcomes[i];\n      const outcomeStrings = finalProbs.map(obj => obj.outcome);\n      const outcomeIndex = outcomeStrings.indexOf(`${outcome}`);\n\n      // add the probability to the outcome\n      if (outcomeIndex >= 0) {\n        finalProbs[outcomeIndex].probability = \n        finalProbs[outcomeIndex].probability + probability;\n      } else {\n        // make a new object if none of the objects have the outcome\n        finalProbs.push({ \n          outcome: `${outcome}`, \n          probability: probability,\n        });\n      }\n    }\n    return finalProbs;\n  };\n\n\n  // ------------------------------- Methods ------------------------------- //\n  /**\n   * Get probability of rollPair based on parent's rollPair\n   * @return {number} probability - probability out of 100% (1.00); for a\n   * specific fraction, use odds instead. \n   */\n  getRelativeProbability (modifiers) {\n    if (this.isRoot()) { return 1.00; } // base: node isRoot\n\n    // get battle roll from parent\n    const pMaxAtk = this.parent.maxAttackers;\n    const pMaxDef = this.parent.maxDefenders;\n    const losses = this.lossFromParent;\n\n    const odds = getOutcomeProbability(pMaxAtk, pMaxDef, losses, modifiers);\n    return odds;\n    // const probability = odds.outcome / odds.total;\n    // return probability;\n  };\n\n  // like relative probability, but multiple by all probabilities from this to\n  // root\n  getRootProbability (modifiers) {\n    // Helper: get probabilities and store them in an array\n    const parentProbs = (node, probabilityArray = []) => {\n      // Add the node's probability to the array\n      probabilityArray.push(node.getRelativeProbability(modifiers));\n\n      // Recursive case: if a parent exists, add its probability\n      if (!node.isRoot()) { parentProbs(node.parent, probabilityArray); }\n      return probabilityArray; \n    };\n\n    const probabilities = parentProbs(this);\n    // console.log(probabilities);\n\n    // Reduce probabilities by multiplying all values together\n    const rootProbability = probabilities.reduce((a, b) => a * b);\n    return rootProbability;\n  };\n\n  /**\n   * Add a RollNode to the end of the RollNode's children array\n   * @param {RollNode} childNode -- node to add to children\n   */\n  addChild (childNode) { this.children.push(childNode); };\n\n  /**\n   * Check if the node is a leaf node (has no children)\n   * @return {boolean}\n   */\n  isLeaf () { return (this.children.length === 0) ? true : false; };\n\n  /**\n   * Check if the node is a root node (has no parent)\n   * @return {boolean}\n   */\n  isRoot () { return (this.parent === null) ? true : false; };\n\n  // TODO: calculate total number of nodes\n\n  /** \n   * Helper function to calculate possible outcomes for next battle\n   * @param {number} attackers - total number of attacking troops\n   * @param {number} defenders - total number of defending troops\n   */ \n  static loseTroops (attackers, defenders) {\n    const troopsLost = (attackers >= 2 && defenders >= 2) ? 2 : 1;\n\n    // Outcomes -- Left: attack loses most, Right: defense loses most\n    const outcomes = [ \n      [attackers - troopsLost, defenders], \n      [attackers, defenders - troopsLost], \n    ];\n  \n    if (troopsLost === 2) {\n      outcomes.push([attackers - 1, defenders - 1]); // Middle\n      [outcomes[1], outcomes[2]] = [outcomes[2], outcomes[1]]; // Swap to middle\n    }  \n    return outcomes;\n  };\n\n  getLeafProbabilities (modifiers) {\n    const getLeafProbs = (node, probs = []) => {\n      if (node.isLeaf()) {\n        probs.push({\n          // outcome: node.lossFromParent,\n          outcome: node.rollPair,\n          probability: node.getRootProbability(modifiers),\n        });\n        return probs;\n      } else {\n        for(let i = 0; i < node.children.length; i++) {\n          getLeafProbs(node.children[i], probs);\n        }\n      }\n      return probs;\n    };\n\n    const leafProbabilities = getLeafProbs(this);\n    return leafProbabilities;\n  };\n\n  /**\n   * Generate the tree of possible outcomes. The root node will be the node that\n   * the function is called on. This modifies that node directly. \n   */\n  makeOutcomesTree () { \n    const rootNode = this;\n\n    // Base case: if the node's pair has any zeroes, it cannot have children\n    /**\n     * Note: this is modifiable. For example, you can change the condition to\n     * generate the tree up to when defenders are equal to attackers\n     */ \n    const [nodeAtk, nodeDef] = [ rootNode.nAttackers, rootNode.nDefenders ];\n    if (nodeAtk === 0 || nodeDef === 0) { return rootNode };\n\n    // Recursive case: create children nodes\n    const outcomes = RollNode.loseTroops(nodeAtk, nodeDef);\n    for (let i = 0; i < outcomes.length; i++) {\n      // Turn the outcomes into RollNodes, make children, and add connect them\n      const newNode = new RollNode(outcomes[i]);\n      newNode.parent = rootNode;\n      newNode.makeOutcomesTree();\n      rootNode.addChild(newNode);\n    }\n    return rootNode;    \n  };\n\n  // combine getting leaf probabilities and reducing them\n  getOdds (modifiers) {\n    this.makeOutcomesTree();\n    const probabilities = this.getLeafProbabilities(modifiers);\n    const reducedOutcomes = RollNode.reduceOutcomes(probabilities);\n    return reducedOutcomes;\n  };\n \n};\n","import React, { useState } from 'react';\nimport './App.scss';\n\nimport { RadioButtons } from './RadioButtons';\n\nimport { \n  RollNode,\n} from './utilities/RollNode';\n\nconst App = () => {\n  const [numAttackers, setNumAttackers] = useState(3);\n  const [numDefenders, setNumDefenders] = useState(2);\n  const [modifiers, setModifiers] = useState({ defender: \"\" });\n\n  const [oddsAttackWins, setOddsAttackWins] = useState([]);\n  const [oddsAttackLoses, setOddsAttackLoses] = useState([]);\n\n  const calculateOdds = (event) => {\n    event.preventDefault();\n\n    const rollTree = new RollNode([numAttackers, numDefenders]);\n    const treeLeafOdds = rollTree.getOdds(modifiers);\n\n    const attackWins = [];\n    const attackLoses = [];\n\n    for (let i = 0; i < treeLeafOdds.length; i++) {\n      if (treeLeafOdds[i].outcome[0] !== '0') { \n        attackWins.push(treeLeafOdds[i]);\n      } else {\n        attackLoses.push(treeLeafOdds[i]);\n      }\n    }\n\n    setOddsAttackWins(attackWins);\n    setOddsAttackLoses(attackLoses);\n  };\n\n  const formatPercent = (decimal) => {\n    const number = parseFloat(decimal) * 100;\n    return `${number.toFixed(2)}%`;\n  };\n\n  const displayTotalOutcome = (outcomeArray, label) => {\n    let probabilitiesSum = \"--\";\n    if (outcomeArray.length > 0) {\n      probabilitiesSum = outcomeArray.map((outcome) => outcome.probability)\n        .reduce((a,b) => a + b)\n      probabilitiesSum = formatPercent(probabilitiesSum);\n    } \n    return (\n      <>\n        <p className=\"outcomesTable__columnLabel\">{label}</p>\n        <p className=\"outcomesTable__columnTotal\">\n          {probabilitiesSum}\n        </p>\n      </>\n    );\n  };\n\n  const displayOutcomes = (outcomeArray) => {\n    const displayedOutcomes = outcomeArray.map((outcome) => {\n      return (\n        <div className=\"outcomesTable__outcomeItem\" key={outcome.outcome}>\n          <p>{outcome.outcome}</p>\n          <p>{formatPercent(outcome.probability)}</p>\n        </div>\n      );\n    });\n\n    return (\n      <ul className=\"outcomesTable__outcomesList\">\n        <div className=\"outcomesTable__outcomeItemLabel\">\n          <p>Outcome</p>\n          <p>Probability</p>\n        </div>\n        {displayedOutcomes}\n      </ul>\n    );\n  };\n\n  // Only works for defenders for now\n  const modifyModifiers = (modifier) => {\n    setModifiers({ defender: modifier });\n  };\n\n  // TODO: calculate median/average outcome\n\n  return (\n    <div className=\"App\">\n      <header className=\"appHeader\">\n        <p className=\"appHeader__title\">Risk Legacy</p>\n        <p className=\"appHeader__subtitle\">Battle Odds Calculator</p>\n      </header>\n\n      <div className=\"outcomesTable\">\n        <div className=\"outcomesTable__column\">\n          { displayTotalOutcome(oddsAttackWins, \"Attacker Wins\") }\n          { displayOutcomes(oddsAttackWins) }\n        </div>\n        <div className=\"outcomesTable__column\">\n          { displayTotalOutcome(oddsAttackLoses, \"Attacker Loses\") }\n          { displayOutcomes(oddsAttackLoses) }\n        </div>\n      </div>\n\n      <form className=\"inputsForm\" onSubmit={(event) => calculateOdds(event)}>\n        <div className=\"inputsForm__section troopCount\">\n          <p className=\"inputsForm__sectionLabel\">Troops</p>\n          <div className=\"troopsInput\">\n\n          <div className=\"inputsForm__input troopsInput__rowItem\">\n            <label className=\"inputsForm__inputLabel\" htmlFor=\"numAttackers\">\n              Attackers\n            </label>\n            <div className=\"inputsForm__inputField\">\n              <input\n                type=\"number\" required\n                name=\"numAttackers\" id=\"numAttackers\"\n                min=\"1\" max=\"15\"\n                value={numAttackers} placeholder=\"0\"\n                onChange={(event) => setNumAttackers(event.target.value)}\n              />\n            </div>\n          </div>\n\n          <div className=\"inputsForm__input troopsInput__rowItem\">\n            <label className=\"inputsForm__inputLabel\" htmlFor=\"numDefenders\">\n              Defenders\n            </label>\n            <div className=\"inputsForm__inputField\">\n              <input\n                type=\"number\" required\n                name=\"numDefenders\" id=\"numDefenders\"\n                min=\"1\" max=\"15\"\n                value={numDefenders} placeholder=\"0\"\n                onChange={(event) => setNumDefenders(event.target.value)}\n              />\n            </div>\n          </div>\n          </div>\n        </div>\n\n        <div className=\"inputsForm__section\">\n          <p className=\"inputsForm__sectionLabel\">Modifiers</p>\n          <div className=\"inputsForm__input\">\n            <label htmlFor=\"defenderModifiers\">Territory Scar</label>\n            <div className=\"inputsForm__inputField\">\n              <RadioButtons\n                buttons={[\n                  { value: \"\", label: \"None\" },\n                  { value: \"bunker\", label: \"Bunker\" },\n                  { value: \"ammoShortage\", label: \"Ammo Shortage\" },\n                ]}\n                callback={modifyModifiers}\n              />\n            </div>\n          </div>\n        </div>\n\n        <button className=\"inputsForm__submit\" type=\"submit\" autoFocus>\n          Calculate\n        </button>\n      </form>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}